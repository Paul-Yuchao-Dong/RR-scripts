
# coding: utf-8

import os, time
import pandas as pd
import numpy as np
import re
from pandas.tseries.offsets import DateOffset, Second, Day

# helper function to split the Eng / Chi names
def split_t_name(T_name):
	e_name = []
	c_name = []
	try:
		names = re.split('/', T_name)
		for name in names:
			if name[0] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz':
				e_name.append(name)
			else:
				c_name.append(name)
		e_name = u'/'.join(e_name)
		c_name = u'/'.join(c_name)
			
	except:
		if T_name[0] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz':
			e_name = T_name
			c_name = 'No Chi Name'
		else:
			c_name = T_name
			e_name = 'No Eng Name'
	return e_name, c_name

# helper function to calculate the months in between dates (backward compatible with LMs)
def months_between(start, end):
	for e in [start, end]:
		if type(e) is not pd.tslib.Timestamp:
			raise TypeError
	end_adj = end + DateOffset(days=1) #this is assuming the lease end at the 24th hour of the expiry date
	diff = (end_adj.year - start.year) * 12 + (end_adj.month - start.month) + (end_adj.day/float(start.daysinmonth) - start.day/float(start.daysinmonth)) 
	return diff

def RR_convert(Path = r'U:\Refinancing analysis\Model',\
 file_name = r'\port_pro_let_kyk_regular_Datafloor.xls',\
 ind_Path = r'U:\Refinancing analysis\Model',\
 ind_file_name = r'\port_pro_let_kyk_rank_Datafloor.xls'):
	"""
	This function serves as a rent roll converter for the at property Leasing Management System (LMS).

	Parameters:
	Path: folder in raw string
	file_name: raw string begin with '\', the file name of the LMS output
	
	ind_Path: folder in raw string, location of the tenant rank file from LMS
	ind_file_name: raw string begin with '\', the file name of the LMS tenant rank file

	Return:
	It would create an excel file "RentRoll.xlsx", as well as return a pandas DataFrame.
	"""
	# #Rent Roll Converter
	# ##1 Set up the environment
	# imports moved to top

	# ##2 Reading from excel file generated by LMS (at-property)
	df = pd.read_excel(Path + file_name, encoding = 'utf-8')
	# ##3 simple tidy up of the column names
	df = (df.rename(columns = lambda x: x.replace(' ', '_'))
			.dropna(axis=1, how='all')      
			)
	# ####LMS data was generated from a database, so it is most likely type consistent
	df = (df.assign(contract_months = lambda x: list(map(months_between, x[u'契約期間　異動日'], x[u'Lease_Term_　End'])),
					base_rent = lambda d: d[u'Rent_Monthly(Yen)']/1000.0,
					rent_start = lambda d: pd.to_datetime(d[u'賃料発生日'], dayfirst = True)
					)
			)
	# ##4 Group by tenant code, lease no., floor and units
	# ####lease no. alone wouldn't work
	lease_grp = df.reset_index().groupby(['Tenant_Code', 'Lease_No._', u'Floor', u'Space_Category　Zone/Type'])
	# ##5 Data Transformation to a more handy set - close to rent roll format
	#Format of the result
	cols = [ 'BLDG',  'FL', 'UNITS', 'ENG NAME', 'CHINESE NAME', 'GFA', 'L_START', 'L_END', 'E_RENT', 'B_RENT', 'ET_DATE', 'TA']
	#this would be clearer if rolled into an function and apply then concatate
	#initialize the output
	RentRoll = pd.DataFrame(columns = cols, index = range(len(lease_grp)))
	i = 0 #index of the new dataframe
	for key, single_ls in lease_grp:
		#simple data fields just copy from the 1st row
		bldg = int(single_ls.iloc[0]['Building_Code'][-1])
		fl = int(single_ls.iloc[0]['Floor'][:-1])
		units = single_ls.iloc[0][u'Space_Category　Zone/Type']
		gfa = round(float(single_ls.iloc[0][u'Leased_Area(m2)']),2)
		ta = single_ls.iloc[0][u'Tenant_Code']
		
		#debugging for SDTJ
		#if ta == "SHI01":
		#    pdb.set_trace()
		
		# split tenant name is a bit tricky, spin it off as a function #TODO more Regex magic 
		e_name, c_name = split_t_name(single_ls.iloc[0][u'Tenant_Name'])
		
		#Nominal start and end of the lease, span of the accounting lease
		l_start = min(single_ls[u'Lease_Term_　Start'])
		l_end = max(single_ls[u'Lease_Term_　End']) + Day(1) - Second(1) # move to the end of day
		length = months_between(l_start, l_end)
		
		#copy the original durations of each sub-period
		contract_months = single_ls.contract_months.copy()
		
		#treat fitout period by reducing the first row of duration - operated on contract_months copy
		if pd.notnull(single_ls.iloc[0][u'賃料発生日']):  #there are fitout period, assume it is always at the beginning    
			actual_begin = pd.to_datetime(single_ls.iloc[0][u'賃料発生日'], dayfirst = True)
			fitout_end = actual_begin - pd.Timedelta('1 Day')
			fitout_months = months_between(single_ls.iloc[0][u'契約期間　異動日'], fitout_end)
			contract_months.iloc[0] -= fitout_months
			
		#regular and iregular rentfree treatment is mutually exclusive in at property system
		#counter-intuitively, the "iregular" rent-free was easy to deal with, effective rent is just the weighted avg
		if pd.isnull(single_ls.iloc[0][u'ﾌﾘｰﾚﾝﾄ開始月']): # if the rent free was not recorded as begin and end months "regular" rent free
			effective_rent = sum(single_ls.base_rent * contract_months) / length / gfa
		
		#for regular rent-free, workout how many months needs to be reduced from actual rent paying months
		else: # if the rent free was recorded as begin and end months "regular" rent free
			regular_rf_mths = int(single_ls.iloc[0][u'ﾌﾘｰﾚﾝﾄ終了月']) - int(single_ls.iloc[0][u'ﾌﾘｰﾚﾝﾄ開始月']) + 1
			regular_rf_mths = regular_rf_mths * round(length / 12, 0) # here is the problem see if round 0 help!
			effective_rent = sum(single_ls.base_rent * (contract_months - regular_rf_mths) ) / length / gfa
		
		#face rent has the added complication of denoting rentfree with 0 base rent, so need to reduce the denominator
		face_rent = single_ls.base_rent.astype(float).dot(contract_months) / sum(contract_months[single_ls.base_rent > 0]) / gfa
		
		#Markdown the cancellation date for the monthly rent roll reconciliation
		if pd.notnull(single_ls.iloc[-1]['Cancellation_Date']):
			et = pd.to_datetime(single_ls.iloc[-1]['Cancellation_Date']) + Day(1) - Second(1)
		else:
			et = pd.NaT
		
		#push the row into the new dataframe
		RentRoll.iloc[i] = [bldg, fl, units, e_name, c_name, gfa, l_start, l_end, effective_rent, face_rent, et, ta]
		i += 1
	RentRoll.L_START = pd.to_datetime(RentRoll.L_START, errors = 'coerce')
	RentRoll.L_END = pd.to_datetime(RentRoll.L_END, errors = 'coerce')
	RentRoll.ET_DATE = pd.to_datetime(RentRoll.ET_DATE, errors = 'coerce')
	RentRoll.GFA = pd.to_numeric(RentRoll.GFA, errors = 'coerce')
	RentRoll.E_RENT = pd.to_numeric(RentRoll.E_RENT, errors = 'coerce')
	RentRoll.B_RENT = pd.to_numeric(RentRoll.B_RENT, errors = 'coerce')
	RentRoll['Real_END'] = np.where(pd.notnull(RentRoll.ET_DATE), RentRoll.ET_DATE, RentRoll.L_END)
	
	
	df_rank = pd.read_excel(ind_Path + ind_file_name, encoding = 'utf-8')

	group_ta = df_rank.groupby(by = 'TenantCode')

	industries = group_ta[u'Type of Industry'].unique()
	d = pd.Series({i:industries[i][0] for i in industries.index})
	d = pd.DataFrame(d, columns= ['Industry',]).reset_index().rename(columns = {'index': 'TA'})
	RentRoll = pd.merge(RentRoll, d, on = 'TA')
	#RentRoll['CHINESE NAME'] = RentRoll['CHINESE NAME'].str.decode('utf8')
    
	
	(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(Path+file_name)
    
	RentRoll.to_excel('RentRoll_%s.xlsx' % time.strftime('%Y-%m-%d', time.localtime(mtime)), encoding = 'utf-8')
	return RentRoll
 
if __name__ == "__main__":
    RR_convert()         